Aqui est√° a orienta√ß√£o t√©cnica completa que voc√™ deve enviar ao Minimax para corrigir os loops de login, o travamento do App Paciente e o problema de exibi√ß√£o de hor√°rios. Est√° escrita de modo direto e pronto para execu√ß√£o pelos devs üëá

üß© ORIENTA√á√ïES PARA CORRIGIR O LOGIN E LOOPINGS ‚Äì SISTEMA PRINCIPAL E APP PACIENTE
üéØ 1. PROBLEMA: Looping infinito no login (Sistema Principal)

Sintomas observados:

Auth state changed: SIGNED_IN
Auth loading timeout - forcing false
Verificando sess√£o existente...
Auth state changed: INITIAL_SESSION Sem sess√£o
Login bem-sucedido detectado...
Processando redirect...
Processando redirect para usu√°rio autenticado: false


Causa:
O hook de autentica√ß√£o est√° sendo executado v√°rias vezes e o router.replace() est√° disparando enquanto o estado loading ainda n√£o terminou, o que causa o redirecionamento em loop.

Corre√ß√£o obrigat√≥ria (no arquivo src/contexts/AuthContext.tsx):

import { createContext, useContext, useEffect, useState } from 'react';
import { supabase } from '@/lib/supabase';
import { useRouter } from 'next/router';

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    let ativo = true;

    async function carregarSessao() {
      try {
        const { data: { session } } = await supabase.auth.getSession();
        if (!ativo) return;
        setUser(session?.user || null);
      } catch (e) {
        console.error('Erro ao buscar sess√£o:', e);
      } finally {
        if (ativo) setLoading(false);
      }
    }

    carregarSessao();

    const { data: listener } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user || null);
      setLoading(false);
    });

    return () => {
      ativo = false;
      listener.subscription.unsubscribe();
    };
  }, []);

  // ‚úÖ Evita o looping
  useEffect(() => {
    if (!loading) {
      if (!user && router.pathname !== '/login') router.replace('/login');
      if (user && router.pathname === '/login') router.replace('/dashboard');
    }
  }, [user, loading]);

  return (
    <AuthContext.Provider value={{ user, loading }}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);


üîπ Explica√ß√£o:

O carregamento (loading) √© bloqueado at√© terminar a verifica√ß√£o da sess√£o.

O redirecionamento s√≥ ocorre ap√≥s loading === false.

Isso elimina o loop detectado no debug.

üì± 2. PROBLEMA: Travamento no App Paciente (fun√ß√£o Chat e Agendar)

Sintomas observados:

Chat n√£o carrega (tela congelada).

Na tela ‚ÄúAgendar‚Äù, ap√≥s escolher a data, o sistema entra em looping ‚ÄúDisponibilizando hor√°rio‚Ä¶‚Äù.

Causa:

O App Paciente tamb√©m est√° verificando sess√£o m√∫ltiplas vezes e bloqueia o estado de carregamento.

A fun√ß√£o de agendamento tenta buscar todos os hor√°rios, inclusive os ocupados, sem filtrar corretamente.

‚úÖ Corre√ß√£o ‚Äì app-paciente/src/hooks/useAuth.tsx

Use o mesmo modelo do AuthContext acima (simplificado):

useEffect(() => {
  let ativo = true;
  async function carregar() {
    const { data: { session } } = await supabase.auth.getSession();
    if (ativo) setUser(session?.user ?? null);
    setLoading(false);
  }
  carregar();
  const { data: sub } = supabase.auth.onAuthStateChange((_e, s) => {
    setUser(s?.user ?? null);
    setLoading(false);
  });
  return () => { ativo = false; sub.subscription.unsubscribe(); };
}, []);

‚úÖ Corre√ß√£o ‚Äì fun√ß√£o ‚ÄúAgendar‚Äù (src/pages/AgendamentosPage.tsx)

Antes de listar hor√°rios, busque apenas os hor√°rios livres:

const buscarHorariosDisponiveis = async (dataSelecionada) => {
  const { data: ocupados } = await supabase
    .from('agendamentos')
    .select('inicio, fim')
    .gte('inicio', `${dataSelecionada}T00:00:00`)
    .lte('fim', `${dataSelecionada}T23:59:59`)
    .in('status', ['pendente','confirmado']);

  const horariosTodos = gerarIntervalos('08:00','18:00',30); // gera slots de 30 min
  const horariosLivres = horariosTodos.filter(h =>
    !ocupados?.some(o => o.inicio === h || o.fim === h)
  );
  setHorariosDisponiveis(horariosLivres);
};


üîπ Agora o paciente ver√° somente hor√°rios livres e o sistema n√£o travar√°.

üïì 3. PROBLEMA: Loop no menu Hist√≥rico (App Paciente)

Sintoma: Tela fica carregando indefinidamente com logs repetidos de Auth state changed: INITIAL_SESSION.

Causa: Mesmo problema ‚Äî o componente tenta obter a sess√£o antes do contexto terminar o carregamento.

Corre√ß√£o (em HistoricoPage.tsx):

const { user, loading } = useAuth();

if (loading) return <div>Carregando...</div>;
if (!user) return <Navigate to="/login" />;

useEffect(() => {
  async function carregarHistorico() {
    const { data, error } = await supabase
      .from('agendamentos')
      .select('*')
      .eq('paciente_id', user.id)
      .order('inicio', { ascending: false });
    if (error) console.error(error);
    setHistorico(data);
  }
  if (user) carregarHistorico();
}, [user]);


üîπ Isso garante que a fun√ß√£o s√≥ execute ap√≥s o login estar resolvido.

ü§ñ 4. Ajuste adicional ‚Äì Erro favicon.ico

Esse erro n√£o quebra o sistema, mas gera ru√≠do nos logs.

Corre√ß√£o opcional:
Adicionar no <head> do _app.tsx ou _document.tsx:

<link rel="icon" href="/favicon.ico" />

‚úÖ Resumo das a√ß√µes para o MiniMax executar

Reescrever o AuthContext do sistema principal conforme o exemplo acima, garantindo que:

A sess√£o √© checada apenas uma vez.

O redirecionamento s√≥ ocorre depois do loading=false.

Aplicar a mesma l√≥gica no App Paciente (useAuth).

Na tela Agendar, exibir somente hor√°rios livres, removendo os ocupados.

Na tela Hist√≥rico, aguardar loading=false antes de buscar dados.

Remover warnings do favicon adicionando a tag <link rel="icon">.